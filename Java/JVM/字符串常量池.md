> 在JDK8中，字符串常量池在堆中

```java
public class Test {
    public static void main(String[] args) {
        String s = new String("1");
        String s1 = s.intern();
        String s2 = "1";

        System.out.println(s1 == s2);
        System.out.println(s == s2);

        String s3 = new String("1") + new String("1");
        s3.intern(); //jdk6中把s3拷贝一份到常量池；而jdk7中只需在常量池记录s3对象的引用
        String s4 = "11"; //在jdk6中指向常量池中s3的拷贝对象；而jdk7中由于常量池中记录了"11"这个字符串对象的引用，所以s4最终指向s3所指向的对象
        System.out.println(s3 == s4);
    }
}
```

```text
true
false
true
```

首先明确以下两点

1. 直接创建字符串时，如`String s = "1"`。则会在常量池中寻找该常量

   - 如果存在则直接返回地址，这里的地址分为两种情况：
     - 堆中的引用的地址（使用`intern()`方法时会出现）
     - 本身常量池的地址如果不存在，那么直接在常量池
   - 如果不存在那么会在常量池中直接创建常量，并返回他在常量池中的地址

2. 使用`new`来创建字符串，如`String s = new String("1")`

   他首先会在堆上创建`String("1")`对象（无论常量池中是否存在相同字面量（就是例子中的`"1"`）的对象）

   然后判断常量池中是否存在相同字面量的对象

   - 如果不存在就会在常量池中创建对象
   - 如果存在不做任何操作

   这里堆上的`String("1")`内部的`value`属性为`char[]`他指向常量池中的`char[]`数组

那么拆解代码中的操作：

1. `String s = new String("1");`

   在常量池中创建`"1"`（常量池的实现是一张哈希表，存储了字符串的引用，这样每个字符串实例在常量池中只会有一份），然后在堆内创建`String("1")`对象，然后让`s`去指向该对象。

2. `String s1 = s.intern();`

   `intern()`方法：如果常量池中存在当前字符串，就会直接返回当前字符串；如果常量池中没有此字符串，会将此字符串放入常量池中后，再返回

   因为常量池中有`"1"`所以`s1`得到的是常量池中的对象

3. `String s2 = "1";`

   直接使用字面量的话会在常量池中寻找相同字面量的对象，如果常量池中找到则直接返回，没找到就会在常量池中创建该字符串。这里因为第一步的时候就在常量池中创建过了的时候就创建过了，所以直接返回常量池中的对象。

4. `String s3 = new String("1") + new String("1");`

   当两个`new`相加时会在堆中这两个对象，并在堆中创建相加后的对象。然后判断常量池中是否存在这两个对象的字面量常量，如果不存在就创建对应的字面量常量。

   这里先在堆中创建了两个`"1"`又在堆中创建了`"11"`的对象，因为常量池中已经有`"1"`的字面量常量，所以不做任何操作。最后`s3`指向堆中的`"11"`

5. `s3.intern();`

   在JDK7以后就直接将`"11"`对应指向堆中`"s3"`对象的引用，不会再重新在常量池中创建字面量对象了。

6. `String s4 = "11";`

   因为第五步将常量池中的`"11"`对应指向堆中`"s3"`的引用，所以这里得到的跟`s3`相同的对象实例。

参考

- https://zhuanlan.zhihu.com/p/92079662
- https://www.cnblogs.com/justcooooode/p/7603381.html