# 1.配置文件

- SpringBoot使用的全局配置文件，配置文件名固定

  - application.properties
  - appllication.yml

  配置文件的作用：修改SpringBoot自动配置的默认值

  配置文件使用的标记语言：

  以前的配置文件：XML，实例如下

  ```xml
  <server>
      <port>8081</port>
  </server>
  ```

  新的配置文件：YAML，是一种**以数据为中心**的标记语言，实例如下

  ```yaml
  server:
  	port: 8888
  ```

  

# 2.YAML语法

## 1.基本语法

`k:(空格)v:`表示一对键值对

以空格的缩进来控制层级关系；只要是左对齐的一列数据都是同一层级

```yaml
server:
	port: 8081
	path: /hello
```

属性和值大小写敏感



## 2.值的写法

### 字面量：普通的值（数字，字符串，布尔）

`k: v: 字面量的值直接写`

字符串默认不用引号

- ""：会转义字符串里面的特殊字符
- ''：不会转义特殊字符

### 对象/Map（属性和值）（键值对）：

`k: v: 在下一行来写对象的属性和值的关系，注意缩进`

还是键值对的方式

```yaml
friend:
	lastName: zhangsan
	age: 20
```

行内写法

```yaml
friend: {lastName: zhangsan,age: 18}
```

### 数组（List、Set）：

用`- 值`表示数组中的一个元素

```yaml
pets: 
	- cat
	- dog
	- pig
```

行内写法

```yaml
pets: [cat,dog,pig]
```



# 3.配置文件值的注入

配置文件（application.yml）：

```yaml
person:
  lastName: zhangsan
  age: 18
  boss: false
  birth: 2017/12/12
  maps: {k1: v1,k2: 12}
  lists:
    - lisi
    - zhaoliu
  dog:
    name: 小狗
    age: 2
```

配置文件（application.properties）：

```properties
#配置文件
#需要将设置编码中的透明ascii开启，不然中文会出现乱码
person.last-name=张三
person.age=18
person.birth=2017/12/15
person.boss=false
person.maps.k1=v1
person.maps.k2=14
person.lists=a,b,c
person.dog.name=dog
person.dog.age=15
```

配置文件中`-n/_n`等同于`N`

JavaBean:

```java
public class Dog {
    private String name;
    private Integer age;
}
```

通过@ConfigurationProperties获取：

```java
/**
 * 将配置文件中每一个值映射到组件中
 * @ConfigurationProperties(prefix = "person"):告诉SpringBoot将本类中的所有属性和配置文件相关配置进行绑定，默认从全局配置文件中获取值
 *      prefix = "person"：配置文件中的哪个下面的所有属性进行映射
 *
 * 只有组件是容器中的组件，才能使用容器中提供的@ConfigurationProperties功能，所以要加加入@Component
 */
@Component
@ConfigurationProperties(prefix = "person")
public class Person {

    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;
    private Map<String ,Object> maps;
    private List<Object> lists;
    private Dog dog;
}
```

通过@Value获取

```java
@Component
public class Person {
    @Value("${person.last-name}")
    private String lastName;
    @Value("#{11*2}")
    private Integer age;
    @Value("true")
    private Boolean boss;
    private Date birth;
    private Map<String ,Object> maps;
    private List<Object> lists;
    private Dog dog;
}
```



我们可以带入配置文件处理器，以后编写配置就有提示

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

## 1.@Vaule获取值和@ConfigurationProperties获取值比较

|                                | @ConfigurationProperties | @Vaule       |
| ------------------------------ | ------------------------ | ------------ |
| 功能                           | 批量注入配置文件中的属性 | 一个一个指定 |
| 松散绑定（松散语法）           | 支持                     | 不支持       |
| SpEl（如`#{11*2}`）            | 不支持                   | 支持         |
| JSR303数据校验（`@Validated`） | 支持                     | 不支持       |
| 复杂类型封装（Map等）          | 支持                     | 不支持       |

- 松散绑定：如配置文件中`-n`等同于`N`

如果在某个业务逻辑中只是想获取某个配置文件的值，就用@Value

如果专门编写了一个JavaBean来和配置文件进行映射，就直接使用@ConfigurationProperties

## 2.配置文件中注入数据校验

```java
@Component
@ConfigurationProperties(prefix = "person")
@Validated
public class Person {
    //@Value("${person.last-name}")
    @Email
    private String lastName;
    //@Value("#{11*2}")
    private Integer age;
    //@Value("true")
    private Boolean boss;
    private Date birth;
    private Map<String ,Object> maps;
    private List<Object> lists;
    private Dog dog;
}
```

## 3.@PropertySource和@ImportResource

### @PropertySource

>  加载指定的配置文件，这样就不用在全局application.properties文件中配置了

在resources下新建一个person.properties，写入

```properties
person.last-name=张三
person.age=18
person.birth=2017/12/15
person.boss=false
person.maps.k1=v1
person.maps.k2=14
person.lists=a,b,c
person.dog.name=dog
person.dog.age=15
```

使用@PropertySource

```java
Component
@PropertySource(value = {"classpath:person.properties"})
@ConfigurationProperties(prefix = "person")
public class Person {
    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;
    private Map<String ,Object> maps;
    private List<Object> lists;
    private Dog dog;
}
```

**注意@ConfigurationProperties不应该删除，因为它指明了配置文件中的哪个下面的所有属性进行映射**

默认配置文件执行顺序application.properties>application.yml>局部properties

### @ImportResource

> 导入Spring的配置文件，让配置文件中的内容生效

SpringBoot里面没有Spring配置文件，我们自己编写的配置文件也不能自动识别

想让Spring的配置文件生效，需要把@ImportResource标注在一个配置类上

```java
@ImportResource(locations = {"classpath:beans.xml"})
```

~~beans.xml(SpringBoot不推荐该做法 )~~

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="helloService" class="com.learning.springboot.service.HelloService"></bean>
</beans>
```



SpringBoot推荐给容器中添加组件的方式（全注解）

1. 配置类===Spring中配置文件
2. 使用@bean给容器中添加组件

```java
/**
 * @Configuration：指明当前类是一个配置类，替代之前的Spring配置文件
 *
 * Spring中用<bean></bean>标签添加组件，这里用@Bean替代
 */
@Configuration
public class MyAppConfig {
    //将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名
    @Bean
    public HelloService helloService(){
        return new HelloService();
    }
}
```

## 4.配置文件占位符

### 1.随机数

`{random.int}` `{random.value}` `{random.long}` `{random.int(10)}` `{random.int[1024,65536]}` 

### 2.占位符

获取之前获取的值，如果之前没有配置该值，可以使用冒号设置默认值

````properties
person.last-name=张三${random.uuid}}
person.age=${random.int}
person.birth=2017/12/15
person.boss=false
person.maps.k1=v1
person.maps.k2=14
person.lists=a,b,c
person.dog.name=${person.hello:hello}_dog
person.dog.age=15
````

## 5.Profile